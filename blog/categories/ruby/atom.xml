<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Dacer Blog]]></title>
  <link href="http://dacer.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://dacer.github.io/"/>
  <updated>2014-02-13T21:42:55+08:00</updated>
  <id>http://dacer.github.io/</id>
  <author>
    <name><![CDATA[Dacer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 3]]></title>
    <link href="http://dacer.github.io/blog/2014/02/13/code-schoolbi-ji-ruby-bits-2-level-3/"/>
    <updated>2014-02-13T15:40:25+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/13/code-schoolbi-ji-ruby-bits-2-level-3</id>
    <content type="html"><![CDATA[<h2>Self</h2>

<p>在class外调用self会返回<code>main</code>，在class内调用会返回class本身。<br/>
如果在定义类中的方法时，在方法名前加<code>self</code>则这个方法会变成类似于Java的静态(static)方法
```ruby
class Tweet
  def self.f(key)</p>

<pre><code>p "#{self}"
</code></pre>

<p>  end
  def Tweet.f &hellip; #与上方一致，但不常用
end
Tweet.f(&ldquo;a&rdquo;) # => Tweet
tweet = Tweet.new
tweet.f(&ldquo;a&rdquo;) # Error!
```</p>

<h3>Class_eval</h3>

<p>重新打开一个class并往里面增加一些东西
```ruby
Tweet.class_eval do</p>

<pre><code>attr_accessor :user
</code></pre>

<p>end
```</p>

<h4>用 class_eval 写一个MethodLogger</h4>

<p>就是记录方法的使用log
```ruby
class MethodLogger</p>

<pre><code>def log_method(klass, method_name) #这里用klass是因为class在ruby中是预置的词
  klass.class_eval do
    alias_method "#{method_name}_original", method_name
    define_method method_name do
      p "#{Time.now}: Called #{method_name}"
      send "#{method_name}_original"
    end
end
</code></pre>

<p>  end
end</p>

<h1>使用</h1>

<p>class Test</p>

<pre><code>def t
end
</code></pre>

<p>end</p>

<p>logger = MethodLogger.new
logger.log_method(Test, :t)
Test.new.t
```</p>

<h3>Instance_eval</h3>

<p>类似于class_eval</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 2]]></title>
    <link href="http://dacer.github.io/blog/2014/02/13/code-schoolbi-ji-ruby-bits-2-level-2/"/>
    <updated>2014-02-13T15:40:25+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/13/code-schoolbi-ji-ruby-bits-2-level-2</id>
    <content type="html"><![CDATA[<h2>Dynamic Classes &amp; Methods</h2>

<h3>Struct</h3>

<p>在一个Class中如果包含的变量都在 initialize 中定义时可以用<code>Struct</code>简化，以下两种定义方式完全相同：
```ruby
class Tweet
  attr_accessor :user, :status
  def initialize(user, status)</p>

<pre><code>@user, @status = user, status
end
</code></pre>

<p>  def to_s</p>

<pre><code>"#{user}: #{status}"
</code></pre>

<p>  end
end
<code>
</code>ruby
Tweet = Struct.new(:user, :status) do
  def to_s</p>

<pre><code>"#{user}: #{status}"
</code></pre>

<p>  end
end
<code>``
如果Class中无需其它方法，其中</code>do&hellip;end`部分也可以省略</p>

<h3>Alias_Method</h3>

<p>在一个Class中复制一个方法，仅改变方法名可以用<code>alias_method</code><br/>
读取一个变量的方法可以用<code>attr_reader</code>简写</p>

<p>```ruby
def tweets</p>

<pre><code>@tweets
</code></pre>

<p>end</p>

<p>def contents
  @tweets
end</p>

<h1>上下两组定义相等</h1>

<p>attr_reader :tweets
alias_method :contents, :tweets
```</p>

<h3>动态生成方法</h3>

<p>```ruby
class Tweet
  def draft</p>

<pre><code>@status = end
def posted
@status = :posted
end
  def deleted
    @status = :deleted
end
</code></pre>

<p>end</p>

<h1>上下两个Class完全一致</h1>

<p>class Tweet
  states = [:draft, :posted, :deleted]
  states.each do |status|</p>

<pre><code>define_method status do
  @status = status
end
end 
</code></pre>

<p>end
<code>
如果动态生成的方法需要参数则可以：
</code>ruby
define_method m do |var|
  games.send(m, var)
end
```</p>

<h3>Send</h3>

<p><code>send</code>方法可以调用class中同名的方法(包括private,protected中的)<br/>
<code>public_send</code>则只能调用公共方法
```ruby
class Timeline
  #&hellip;</p>

<p>  private</p>

<p>  def private_method
  end
end
t = Timeline.new
t.private_method #ERROR
t.public_send(:private_method)
t.send(:private_method)
t.send(&ldquo;private_method&rdquo;)</p>

<p>t.send(:private_method,&ldquo;&rdquo;,var)#有参数时
```</p>

<h3>The Method Method</h3>

<p><code>.method</code>方法可以得到一个class的方法并保存起来,再次调用的方式为<code>call</code>，类似于<code>Proc</code>
<code>ruby
show_method = timeline.method(:show_tweet)
show_method.call
</code>
Turn the Method object into a Proc object:
```ruby
(0..1).each(&amp;show_method)</p>

<h1>上下相同</h1>

<p>show_method.call(0)
show_method.call(1)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 1]]></title>
    <link href="http://dacer.github.io/blog/2014/02/12/code-schoolbi-ji-ruby-bits-2-level-1/"/>
    <updated>2014-02-12T19:02:51+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/12/code-schoolbi-ji-ruby-bits-2-level-1</id>
    <content type="html"><![CDATA[<h2>Blocks, Procs and Lambdas</h2>

<p>Block保存可以使用<code>Proc.new</code>和<code>Lambda</code>.</p>

<h3>Proc.new</h3>

<p>Proc可以用<code>{}</code>或者<code>do end</code>来定义，<code>call</code>来执行
```ruby
my_proc = Proc.new{ p &ldquo;proc&rdquo; }
my_proc = Proc.new do</p>

<pre><code>p "proc"
</code></pre>

<p>end
my_proc.call
```</p>

<h3>Lambda</h3>

<p>Lambda可以直接用<code>= -&gt;</code>来定义<strong>(Ruby1.9以上)</strong>
<code>ruby
my_proc = lambda { p "proc" }
my_proc = lambda do
  p "proc"
end
my_proc = -&gt; { p "proc" }
my_proc.call
</code></p>

<h3>使用场景</h3>

<p>可以把Proc直接作为变量传入方法的参数中
```ruby
def print(proc)</p>

<pre><code>proc.call
</code></pre>

<p>end</p>

<p>my_proc = &ndash;> { p &ldquo;proc&rdquo; }
print(my_proc) # &ldquo;proc&rdquo;
```</p>

<h3>需要注意</h3>

<p><code>&amp;</code>可以把proc变为block
<code>ruby
tweets.each(&amp;printer)
</code>
当定义的方法中需要用到 block 时可以：
<code>ruby
 def each(&amp;block)
   tweets.each(&amp;block)
 end
</code></p>

<h3>其它</h3>

<ul>
<li>在方法中用<code>block_given?</code>可以知道调用此方法时是否提供了block</li>
<li>lambda在生成时可以记住。。什么 <strong>需要回顾一下</strong>
```ruby
def tweet_as(user)
lambda { |tweet| p &ldquo;#{user}: #{tweet}&rdquo;}
end</li>
</ul>


<p>dacer_tweet = tweet_as(&ldquo;dacer&rdquo;)
dacer_tweet.call(&ldquo;Hello&rdquo;) # => dacer: Hello
```</p>

<h3>个人想法</h3>

<p>Proc其实和<code>def</code>定义的方法一样是一串代码的集合，但是Proc可以作为参数放入方法中。<br/>
需要注意的是：
```ruby
proc = lambda { |a| puts a }</p>

<p>def test(&amp;action)</p>

<pre><code>ary = ["a","b","c"]
ary.each(&amp;action)
</code></pre>

<p>end</p>

<p>test &amp;proc
<code>
中去掉任意一个`&amp;`时都会报错
</code>
in `each': wrong number of arguments (1 for 0) (ArgumentError)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开新坑了，基于sinatra的中韩汇率查看网站]]></title>
    <link href="http://dacer.github.io/blog/2013/09/29/e5bc80e696b0e59d91e4ba86efbc8ce59fbae4ba8esinatrae79a84e4b8ade99fa9e6b187e78e87e69fa5e79c8be7bd91e7ab99/"/>
    <updated>2013-09-29T23:15:16+08:00</updated>
    <id>http://dacer.github.io/blog/2013/09/29/e5bc80e696b0e59d91e4ba86efbc8ce59fbae4ba8esinatrae79a84e4b8ade99fa9e6b187e78e87e69fa5e79c8be7bd91e7ab99</id>
    <content type="html"><![CDATA[<p><a href="http://huilv-idacer.rhcloud.com/">&mdash;-点击查看&mdash;&ndash;</a></p>

<p>大概就是sinatra做后端进行post等行为在银联官网上读取银联汇率，前端直接显示结果。</p>

<p>部署在了openshift上（就剩1个免费份额了好捉急！）</p>

<p>显示效果嘛很明显是抄袭google now。。果然我的设计是硬伤。。</p>

<p>当然这个是开源的，不过没啥意义就是了。。</p>

<p>github: <a href="https://github.com/dacer/RMB2WON">https://github.com/dacer/RMB2WON</a></p>

<p>todos:
• <del>汇率计算器 触摸和输入型</del></p>

<p>• FAQ</p>

<p>analytic</p>
]]></content>
  </entry>
  
</feed>
