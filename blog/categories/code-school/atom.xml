<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code School | Dacer Blog]]></title>
  <link href="http://dacer.github.io/blog/categories/code-school/atom.xml" rel="self"/>
  <link href="http://dacer.github.io/"/>
  <updated>2014-02-15T21:22:51+08:00</updated>
  <id>http://dacer.github.io/</id>
  <author>
    <name><![CDATA[Dacer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 3]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-3/"/>
    <updated>2014-02-15T15:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-3</id>
    <content type="html"><![CDATA[<h3>Scopes</h3>

<p>```ruby
scope :sold, &ndash;>{ where(state: &lsquo;sold&rsquo;) } #scopes should take a proc object</p>

<p>default_scope { where(state: &lsquo;available&rsquo;) }
default_scope &ndash;>{ where(state: &lsquo;available&rsquo;) } #defaults scopes should take proc object or a block￼￼
```</p>

<h3>Eager-Loaded Scopes</h3>

<p><code>ruby
scope :recent, -&gt;{ where(published_at: 2.weeks.ago) }
scope :recent_red, -&gt;{ recent.where(color: 'red') }
</code></p>

<h3>Relation#None</h3>

<p><code>.none</code>可以返回一个空的 ActiveRecord::Relation，避免在使用空的<code>array</code>时出现错误
<code>ruby
case role
when "Reviewer"
  Post.published
when "Bad User"
  Post.none
end
</code></p>

<h3>Relation#Not</h3>

<p>在使用<code>where</code>寻找时如果参数是<code>nil</code>的话会报 SQL 错误，使用<code>.where.not</code>则会自动判别参数是否为空，且在非空时才执行SQL语句
<code>ruby
Post.where.not(author: author)
</code></p>

<h3>Relation#Order</h3>

<p>在 Rails 4 中如果<code>default_scope</code>已经有了<code>order()</code>后，再执行<code>.order</code>时这两者的先后顺序与 3 相反， Rails 4 会将<code>default_scope</code>中的放在后面：
```ruby
class User &lt; ActiveRecord::Base</p>

<pre><code>default_scope { order(:name) }
</code></pre>

<p>end</p>

<p>User.order(&ldquo;created_at DESC&rdquo;)</p>

<p>SELECT * FROM users ORDER BY name asc, created_at desc # Rails 3
SELECT * FROM users ORDER BY created_at desc, name asc # Rails 4
```</p>

<h4>手动排序</h4>

<p>Rails 4 可以使用 Hash 来排序
<code>ruby
User.order(:name, created_at: :desc)
User.order(created_at: :desc)
</code></p>

<h4>后面缩写的意思</h4>

<p>Asc : ascending order 递增<br/>
Desc : descending order 递减</p>

<h3>Relation#References</h3>

<p><code>ruby￼
Post.includes(:comments).
  where("comments.name = 'foo'").references(:comments)
</code>
上例中，<code>.include</code>使返回值包含了与 Post 相关联的 comments，
在一下情况则无需使用<code>references</code>
```ruby
Post.includes(:comments).where(comments: { name: &lsquo;foo&rsquo; })
Post.includes(:comments).where(&lsquo;comments.name&rsquo; => &lsquo;foo&rsquo;) #hash-based conditions</p>

<p>Post.includes(:comments).order(&lsquo;comments.name&rsquo;) #no conditions
```</p>

<h3>ActiveModel::Model</h3>

<p><code>ruby
￼class SupportTicket
  include ActiveModel::Conversion
  include ActiveModel::Validations
  extend ActiveModel::Naming
  attr_accessor :title, :description
  validates_presence_of :title
  validates_presence_of :description
end
</code>
可以简化为：
<code>ruby
class SupportTicket
  include ActiveModel::Model
  attr_accessor :title, :description
  validates_presence_of :title
  validates_presence_of :description
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 2]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-2/"/>
    <updated>2014-02-15T15:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-2</id>
    <content type="html"><![CDATA[<h3>Finders</h3>

<p>米什么好说的
<code>ruby
Post.where(author: 'admin') # returns an ActiveRecord::Relation
</code></p>

<h3>Find_By</h3>

<p><code>ruby
Post.find_by(title: 'Rails 4') #returns a single model object, or possibly a collection of model objects in an Array (not a Relation). If nothing is found, an ActiveRecord::RecordNotFound exception is raised.
</code></p>

<h4>Find_by 与 where</h4>

<p>用源码解释：
```ruby
def find_by(*args)</p>

<pre><code>where(*args).take
</code></pre>

<p>end
<code>
所以可以接受和 where 一样的 arguments
</code>ruby
Post.find_by(&ldquo;published_on &lt; ?&rdquo;, 2.weeks.ago)
```</p>

<h3>Find_or_*</h3>

<p>Rail 4 简化了 3 的<code>Find_or_*</code>方法
<code>ruby
Post.find_or_initialize_by(title: "rails 4")
Post.find_or_create_by(title: "rails 4")
</code>
其中<code>find_or_create_by</code>可以和<code>after_create</code>相结合使用：
```ruby
Post.find_or_create_by(title: &lsquo;Rails 4&rsquo;)</p>

<h1>if Post not found ↓</h1>

<p>Post.create(title: &lsquo;Rails 4&rsquo;)</p>

<p>class Post &lt; ActiveRecord::Base</p>

<pre><code>after_create :foo
def foo
  posts = Post.where(author: 'admin')
  ...
    end
</code></pre>

<p>end
```</p>

<h3>Update &amp; Update_column</h3>

<p><code>ruby
@post.update(post_params) #update attribute
@post.update_columns(post_params)
</code></p>

<h3>Model.all</h3>

<p><code>ruby
@tweets = Tweet.all # returns an ActiveRecord::Relation
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 1]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-1/"/>
    <updated>2014-02-15T15:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-1</id>
    <content type="html"><![CDATA[<h2>Match Routes</h2>

<p>有两种方式
<code>
post '/somewhere', to: 'controller#action'
match '/somewhere', to: 'controller#action', via: :post
match '/somewhere', to: 'controller#action', via: :all
</code></p>

<h2>Concern</h2>

<p>用来简化route
```
concern :sociable do
  resources :comments
  resources :tags
end</p>

<p>resources :posts, concerns: :sociable
resources :items, concerns: :sociable
<code>
可以加上选项
</code>
concern :sociable do |options|
  resources :comments, options
  resources :tags, options
end</p>

<p>resources :msgs, concerns: :sociable
resources :posts, concerns: :sociable
resources :items do
  concerns :sociable, only: :create
end
<code>
可以单独封装起来
</code>ruby</p>

<h1>app/concerns/sociable.rb</h1>

<p>class Sociable</p>

<pre><code>def self.call(mapper, options)
  mapper.resources :comments, options
mapper.resources :tags, options
</code></pre>

<p>  end
end</p>

<h1>routes.rb</h1>

<p>concern :sociable， Sociable</p>

<h1>&hellip;</h1>

<p>```</p>

<h3>Thread-Safety</h3>

<p>In Rails 4
<code>ruby
MyApp::Application.configure do
  config.cache_classes = true
  config.eager_load = true
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 5 & 6]]></title>
    <link href="http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-5/"/>
    <updated>2014-02-14T15:40:25+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-5</id>
    <content type="html"><![CDATA[<h2>DSL</h2>

<p>yield</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 4]]></title>
    <link href="http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-4/"/>
    <updated>2014-02-14T15:40:25+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-4</id>
    <content type="html"><![CDATA[<h2>Handling Missing Methods</h2>

<p>在class中可以定义一个<code>method_missing</code>方法，当调用这个class中不存在的方法时会变为调用此方法。
```ruby
class Tweet
  def method_missing(method_name, *args)</p>

<pre><code>puts "You tried to call #{method_name} with these arguments: #{args}"
#super 可以调用ruby default方法， raises a NoMehodError.
</code></pre>

<p>  end
end
Tweet.new.submit(1, &ldquo;Here&rsquo;s a tweet.&rdquo;) # You tried to call submit with arguments: [1, &ldquo;Here&rsquo;s a tweet.&rdquo;]
<code>
利用`method_missing`可以简化很多代码，下例中就是把这个方法所在的class中的方法链接到`@user`的同名方法中了
</code>ruby
def method_missing(method_name, *args)</p>

<pre><code>@user.send(method_name, *args)
</code></pre>

<p>end
<code>
把上面的代码改进一下可以限定方法名
</code>ruby
class Tweet
  DELEGATED_METHODS = [:username, :avatar]
  def initialize(user)</p>

<pre><code>@user = user
end
</code></pre>

<p>  def method_missing(method_name, *args)</p>

<pre><code>if DELEGATED_METHODS.include?(method_name)
  @user.send(method_name, *args)
else
        super 
    end
end 
</code></pre>

<p>end
<code>
Ruby也自带了一个`delegate`可以很方便的实现上述代码
</code>ruby
require &lsquo;delegate&rsquo;
class Tweet &lt; SimpleDelegator
  def initialize(user)</p>

<pre><code>super(user)
</code></pre>

<p>  end
end
```</p>

<h3>一个跟本节不相关的知识点</h3>

<p>正则表达式提取方法：
```ruby
match = name.to_s.match(/^hash_(/w+)/)
match[1] if match #返回符合的首个子字符串，如果存在的话</p>

<pre><code>              #0为返回整个
</code></pre>

<p>```</p>

<h3>Respond_to?</h3>

<p>Tells us if an object responds to a given method<br/>
似乎可以翻译成回应一个object是否有所给的方法？
<code>ruby
tweet = Tweet.new
tweet.respond_to?(:to_s) # =&gt; true
</code>
需要注意的是，用<code>method_missing</code>实现的方法在<code>respond_to?</code>下会返回false的，所以要做如下修改：
```ruby
def respond_to?(method_name)</p>

<pre><code>method_name =~ /^hash_\w+/ || super # ||的作用是在||之前不为nil的时候返回之前的，为nil的时候返回后者
#LIST.include?(method_name.to_s) || super #或者是从一个array中判断
</code></pre>

<p>end
<code>
但是这又带来了一个问题，`.method`方法仍是error
</code>ruby
tweet.method(:hash_ruby)
<code>
在1.9.3以上版本中可以这样解决：变为`respond_to_missing?`，这样`method`就能正确返回一个 method object
</code>ruby
def respond_to_missing?(method_name)</p>

<pre><code>method_name =~ /^hash_\w+/ || super
</code></pre>

<p>end
```</p>

<h3>在 call 一个未定义方法时定义它</h3>

<p>其实我还不太理解这种用法的意义在哪儿。。
```ruby
def method_missing(method_name, *args)</p>

<pre><code>match = method_name.to_s.match(/^hash_(\w+)/)
if match
    self.class.class_eval do
        define_method(method_name) do
        @text &lt;&lt; " #" + match[1]
        end
    end
    send(method_name)
else 
    super
end 
</code></pre>

<p>end
```</p>
]]></content>
  </entry>
  
</feed>
