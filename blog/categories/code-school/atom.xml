<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code School | Dacer Blog]]></title>
  <link href="http://blog.dacer.im/blog/categories/code-school/atom.xml" rel="self"/>
  <link href="http://blog.dacer.im/"/>
  <updated>2014-03-03T22:32:00+09:00</updated>
  <id>http://blog.dacer.im/</id>
  <author>
    <name><![CDATA[Dacer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - jQuery Part2 level 5]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/19/code-school-bi-ji-jquery-part2-level-5/"/>
    <updated>2014-02-19T12:13:03+09:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/19/code-school-bi-ji-jquery-part2-level-5</id>
    <content type="html"><![CDATA[<h2>Advanced Events</h2>

<h3>Removing event handlers</h3>

<p>使用<code>off(&lt;event name&gt;)</code>可以取消监听
<code>javascript
$('button').off('click'); //可以取消所有对 $('button') 的监听
</code></p>

<h3>Namespacing Events</h3>

<p>可以给 event 取一个后缀的别名：
<code>javascript
$('button').on('click.image', picture);
$('button').on('click.details', status);
$('button').off('click.image');  //仅取消对第一个的监听
$('button').off('.image');       //取消所有后缀是.image的监听
</code></p>

<h3>Triggering Events</h3>

<p>可以用来模拟用户行为：
<code>javascript
$('button').trigger('click'); //相当于点击了 button
</code></p>

<h3>Custom Event</h3>

<p>可以自定义一个 event 的名字，然后哦那个 trigger 调用
<code>javascript
$(&lt;dom element&gt;).on("&lt;event&gt;.&lt;namespace&gt;", &lt;method&gt;)
$('.vacation').on('show.price', showPrice);
$('.vacation').trigger('show.price');
$('.vacation:last').trigger('show.price');
</code></p>

<h3>jQuery Plugins</h3>

<p>```javascript
$.fn.priceify = function() {</p>

<pre><code>console.log('Pricify Called');
console.log(this); //Within the plugin, ‘this’ will be the jQuery object the plugin was called on
</code></pre>

<p>};</p>

<p>$(&lsquo;.vacation&rsquo;).priceify();
<code>``
然后简单的研究了一下</code>fn`</p>

<blockquote><p>In jQuery, the <code>fn</code> property is just an alias to the <code>prototype</code> property.</p></blockquote>

<p>然后<code>$.fn</code>似乎就是构造出了一个所有 jQuery Object 都能使用的方法，然后这个 Object 会以 <code>this</code> 传入，不过需要注意的是调用它的有可能是多个 Object ，所以要用 <code>each</code> 来保证每个 Object 会单独的调用这个方法:
```javascript
$.fn.priceify = function() {</p>

<pre><code>this.each(function(){
    ...
})
</code></pre>

<p>};
```</p>

<h3>Plugins with Parameters</h3>

<p>就是传入了一个Hash
```javascript
$.fn.priceify = function(options) {</p>

<pre><code>...
var details = $('&lt;p&gt;Book ' + options.days + ' days for $' +
               (options.days * price) + '&lt;/p&gt;');
</code></pre>

<p>}
$(&lsquo;.vacation&rsquo;).priceify({ days: 5 });  //调用
```</p>

<p>如果想让options变成可选项，就是有一个默认值的话就先要了解 <code>$.extend</code></p>

<h3>Using $.extend</h3>

<p><code>$.extend</code>方法可以传入数个Hash，然后返回的值会合并相同的并且去除空的，如：</p>

<p><code>javascript
$.extend({ days: 3 }, {}); // -&gt; { days: 3 }
$.extend({ days: 3 }, { days: 5 }); // -&gt; { days: 5 }
</code> <br/>
使用<code>$.extend</code>来设置默认值的方法：
```javascript
$.fn.priceify = function(options) {</p>

<pre><code>this.each(function(){
    var settings = $.extend({ days: 3 }, options);
})
</code></pre>

<p>};
```</p>

<p>还可以扩展一下：
```javascript
$.fn.priceify = function(options) {</p>

<pre><code>this.each(function(){
    var settings = $.extend({ days: 3 }, options);
})
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - jQuery Part2 level 3 & 4]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/18/code-school-bi-ji-jquery-part2-level-3-and-4/"/>
    <updated>2014-02-18T12:13:03+09:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/18/code-school-bi-ji-jquery-part2-level-3-and-4</id>
    <content type="html"><![CDATA[<h2>Ajax Forms</h2>

<p>```javascript
$(&lsquo;form&rsquo;).on(&lsquo;submit&rsquo;, function(event) {
  event.preventDefault();  //阻止原按钮的行为
  var form = $(this);      //这样保存form为变量可以减少 DOM queries
  $.ajax(&lsquo;/book&rsquo;, {</p>

<pre><code>type: 'POST',
data: form.serialize(), //可以合并form中所有的 fields 作为data
success: function(result) {
  form.remove();
  $('#vacation').hide().html(result).fadeIn();
} 
</code></pre>

<p>  });
});
```</p>

<h3>With Json</h3>

<p>```javascript
$(&lsquo;form&rsquo;).on(&lsquo;submit&rsquo;, function(e) {
  event.preventDefault();
  var form = $(this);
  $.ajax($(&lsquo;form&rsquo;).attr(&lsquo;action&rsquo;),{   //自动从html的form中获取要post的地址</p>

<pre><code>type: $('form').attr('method'),   //自动获取 发送方式
contentType: 'application/json',  //让服务器返回 json 格式的数据
dataType: 'json',                 //使发出的数据格式为 json
data: form.serialize(),
    success: function(result) {
      form.remove();
      var msg = $("&lt;p&gt;&lt;/p&gt;");
      msg.append("Destination: " + result.location + ". ");
      msg.append("Price: " + result.totalPrice + ". ");
      msg.append("Nights: " + result.nights + ". ");
      msg.append("Confirmation: " + result.confirmation+ ".");
      $('#vacation').hide().html(msg).fadeIn();
    }
});
</code></pre>

<p>});
```</p>

<h3>Utility Methods</h3>

<p><code>javascript
$('.class').find('p') //可以找到某个 .. 中的 某个 ..
$(".book-title:eq("+index+")") //可以找到 class中的第 index 项
</code>
<code>each</code></p>

<p><code>javascript
success: function(result) {
  $.each(result, function(index, city) {...});
}
</code></p>

<p><code>getJSON</code>专为json而简化后的ajax
<code>javascript
￼$.getJSON('/status', function(result) { });
</code></p>

<p><code>map</code>将一个 array 中每个数据处理之后整合出一个新的array
```javascript
$.map(collection, function(<item>, <index>){});</p>

<p>//example
var myNumbers = [1,2,3,4];
var newNumbers = $.map(myNumbers, function(item, index){ return item + 1 });
// myNumbers  &ndash;> [1,2,3,4]
// newNumbers &ndash;> [2,3,4,5]
<code>
用map将json数据转化为html
</code>
$.map(result, function(status, i) {
  var listItem = $(&lsquo;<li></li>&rsquo;);
  $(&lsquo;<h3>&rsquo;+status.name+&lsquo;</h3>&rsquo;).appendTo(listItem); //用appendTo可以将 .. 插入到 listItem其中
  $(&lsquo;<p>&rsquo;+status.status+&lsquo;</p>&rsquo;).appendTo(listItem);
  return listItem;
});
//结果：
<li>
  <h3>Dacer</h3>
  <p>Blog</p>
</li>
<code>
map返回的array可以直接放入html中
</code>javascript
var statusElements = $.map(&hellip;);
$(&lsquo;.status-list&rsquo;).html(statusElements);
<code>``
</code>each<code>返回的是原 array，而</code>map`返回的是 return 的值的 array</p>

<h3>Detach</h3>

<p>.detach() removes an element from the DOM, preserving all data and events.<br/>
This is useful to minimize DOM insertions with multiple html elements.<br/>
.detach() removes the list from the DOM, then it can be modified and reinserted into the status element.
我对此的理解是detach能将一个 element 移出 DOM ，然后对它进行任何操作都不会对网页造成影响，修改完这个 element 之后再将其放回 DOM 。
```javascript
$(&lsquo;.status-list&rsquo;).detach()</p>

<pre><code>             .html(statusElements)
             .appendTo('.status');
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 7]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/18/code-school-bi-ji-zombie-outlaws-level-7/"/>
    <updated>2014-02-18T12:10:57+09:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/18/code-school-bi-ji-zombie-outlaws-level-7</id>
    <content type="html"><![CDATA[<h2>ActionController Live &amp; Turbolinks</h2>

<p>使用<code>ActionController::Live</code>可以让服务器和 client 保持
```ruby</p>

<h1>controllers/items_controller.rb</h1>

<p>class ItemsController &lt; ApplicationController
  include ActionController::Live
end
<code>
默认的 WEBrick 会断开连接，所以要使用  Puma or Rainbows or other compatible servers
</code>ruby
gem &lsquo;puma&rsquo;
<code>
使用方法：
</code>ruby</p>

<h1>controllers/items_controller.rb</h1>

<p>def show</p>

<pre><code>response.headers["Content-Type"] = "text/event-stream" 
3.times {
    response.stream.write "Hello, browser!\n" #write一定要在设置了 headers 之后
    sleep 1 
}
</code></pre>

<p>  response.stream.close
end
```</p>

<h3>EventSource</h3>

<p>使用js的方法：
```javascript
$(document).ready(initialize);
function initialize() {
  var source = new EventSource(&lsquo;/items/events&rsquo;);
  source.addEventListener(&lsquo;message&rsquo;, update);
};</p>

<p>function update(event) {
  var item = $(&lsquo;<li>&rsquo;).text(event.data);
  $(&lsquo;#items&rsquo;).append(item);
}
```</p>

<h3>使用Redis</h3>

<p>```ruby</p>

<h1>controllers/items_controller.rb</h1>

<p>def events
  response.headers[&ldquo;Content-Type&rdquo;] = &ldquo;text/event-stream&rdquo;
  redis = Redis.new
  redis.subscribe(&lsquo;item.create&rsquo;) do |on|</p>

<pre><code>on.message do |event, data|
  response.stream.write("data: #{data}\n\n")
    end 
end
</code></pre>

<p>  response.stream.close
end
```</p>

<h2>Turbolinks</h2>

<p>Rails 4 中默认使用 Turbolinks 通过 ajax 来加快点击 link 之后的跳转速度</p>

<p>Turbolinks 会自动判断载入的 css js 有无改动
<code>
&lt;%= stylesheet_link_tag "application", media:
  "all", "data-turbolinks-track" =&gt; true %&gt;
&lt;%= javascript_include_tag "application",
  "data-turbolinks-track" =&gt; true %&gt;
</code></p>

<h3>启用方法</h3>

<p>以下在 Rails 4 中默认启用
```</p>

<h1>Gemfile</h1>

<p>gem &lsquo;turbolinks&rsquo;</p>

<h1>assets/javascripts/application.js</h1>

<p> //= require turbolinks
```</p>

<h3>Turbolinks Events</h3>

<p>用 js 监听时要注意使用<code>page:load</code>，来初始化监听，以免点击link后监听失效
```javascript
function initialize() {
  $(&lsquo;#owner_active&rsquo;).click( function() {</p>

<pre><code>alert(this.checked);
</code></pre>

<p>  });
}
$(document).ready(initialize);
$(document).on(&lsquo;page:load&rsquo;, initialize);
```</p>

<p>或者可以用一个 gem 自动实现上述代码，ready() will always fire after &ldquo;page:load&rdquo;
```</p>

<h1>Gemfile</h1>

<p>gem &lsquo;jquery-turbolinks&rsquo;</p>

<p>assets/javascripts/application.js
 //= require jquery
 //= require jquery.turbolinks  #order is important!
 //= require jquery_ujs
 //= require turbolinks
<code>
￼
另一种监听方式：
</code>javascript
function checkAlert() {
  alert(this.checked);
}
$(document).on(&lsquo;click&rsquo;, &lsquo;#owner_active&rsquo;, checkAlert);
```</p>

<p>监听<code>page:fetch</code>和<code>page:change</code> 可以用来显示loading
<code>javascript
$(document).on('page:fetch', function() {
  $('#loading').show();
});
$(document).on('page:change', function() {
  $('#loading').hide();
});
</code></p>

<h3>取消 Turbolinks</h3>

<p>Turbolinks affect all internal links by default, but you may not want all links to use it:
<code>
&lt;%= link_to 'Requests', requests_path, "data-no-turbolink" =&gt; true %&gt;
</code>
If a parent has the attribute, all children will be opted-out of Turbolinks:
```</p>

<div id="navigation" data-no-turbolink="true">
  <%= link_to 'Show', @request %> |
  <%= link_to 'Back', requests_path %>
</div>


<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - jQuery Part2 level 1 & 2]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-jquery-part2-level-1-and-2/"/>
    <updated>2014-02-17T21:10:57+09:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-jquery-part2-level-1-and-2</id>
    <content type="html"><![CDATA[<h3>Ajax Basics</h3>

<p>使用Ajax时需要在网站后加上<code>?dc=123</code>之类的参数时可以用<code>data</code>
```javascript
$.ajax(&lsquo;confirmation.html&rsquo;, {
   success: function(response) {</p>

<pre><code> $('.ticket').html(response).slideDown();
</code></pre>

<p>   },
   data: { &ldquo;author&rdquo;: dacer }
   }
});
//confirmation.html?author=dacer
<code>
timeout
</code>javascript
$.ajax(&lsquo;confirmation.html&rsquo;, {
   &hellip;,
   timeout: 3000 //3000ms = 3 seconds
});
<code>`
还有`beforeSend</code>complete`等</p>

<h3>Event Delegation</h3>

<p>当你用jquery监听点击事件时只会在网页加载完毕后执行监听，如果是用ajax创造出来的是无法监听到的，所以要用到<code>Event Delegation</code>
<code>javascript
$('.confirmation .view-boarding-pass').on('click', function(){ ... }); //无法监听到
$('.confirmation').on('click', '.view-boarding-pass', function(){ ... });
</code>
以上代码是监听<code>.confirmation</code>中的点击事件，每次<code>.confirmation</code>中有元素被点击了之后都会检查是否是<code>.view-boarding-pass</code></p>

<h3>Javascript Object</h3>

<p>用<code>var</code>可以声明一个 Object ，然后将其中的function提取出来使代码更整洁
```javascript
var confirmation = {
  init: function() {</p>

<pre><code>$('.confirmation').on('click', 'button', this.loadConfirmation);
$('.confirmation').on('click', '.view-boarding-pass', this.showBoardingPass); 
</code></pre>

<p>  },
  loadConfirmation: function() {</p>

<pre><code>$.ajax('confirmation.html', { ... });
</code></pre>

<p>  },
  showBoardingPass: function(event) { &hellip; }
};</p>

<p>$(document).ready(function() {
  confirmation.init();
});
```</p>

<h3>Javascript Function</h3>

<p>用驼峰法命名一个js的function
<code>javascript
function Blog(author) {
  // init
}
var blog = new Blog('Dacer');
</code></p>

<p>function中可以嵌套function
```javascript
function Blog(author) {
  this.print = function(){</p>

<pre><code>console.log(author)
</code></pre>

<p>  }
}
var blog = new Blog(&lsquo;Dacer&rsquo;);
blog.print(); //&ldquo;Dacer&rdquo;
```</p>

<h3>用 Function 重构之前的代码</h3>

<p>```javascript
function Confirmation(el) {
  this.el = el;
  this.ticket = this.el.find(&lsquo;.ticket&rsquo;);
  var confirmation = this;
  this.loadConfirmation = function() {</p>

<pre><code>$.ajax('confirmation.html', {
  timeout: 3000,
  context: confirmation, //因为ajax内部的this和外部的不同，所以用context把内部的this替换成外部的
  success: function(response) {
    this.ticket .html(response).slideDown(); 
  }
}); 
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 6]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-zombie-outlaws-level-6/"/>
    <updated>2014-02-17T12:10:57+09:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-zombie-outlaws-level-6</id>
    <content type="html"><![CDATA[<h2>ETags,Dalli, &amp; Cache-Digests</h2>

<h3>ETags</h3>

<p>在client请求网页时Rail 4会生成ETags一并发送回去，且client在第二次请求时会将ETags返回回来，此时Rails会再次生成ETags并与之比对，如果相同则返回304让client直接读取缓存的内容。<br/>
换句话说就是ETags是用来判断一个page是否有改变。</p>

<h3>Setting Custom ETags</h3>

<p>可以自定义ETags，<code>fresh_when</code>就是将Etags与<code>@item</code>相关联，在<code>@item.cache_key</code>不变时返回的Etags也相同，和上一节一样返回304
```ruby
class ItemsController &lt; ApplicationController
  def show</p>

<pre><code>@item = Item.find(params[:id])
</code></pre>

<p>￼    fresh_when(@item) # => headers[&lsquo;ETag&rsquo;] = Digest::MD5.hexdigest(@item.cache_key)
  end
end</p>

<h1>@item.cache_key</h1>

<h1>= &lsquo;item/2-2011224150000&rsquo;</h1>

<h1>= <model name>/ <id>&ndash;&lt;updated_at></h1>

<p>```</p>

<h3>Declarative Etags</h3>

<p>可以简化Etags的代码：
```ruby
class ItemsController &lt; ApplicationController
  etag { current_user.id }
  etag { current_user.age }
  def show</p>

<pre><code>@item = Item.find(params[:id])
fresh_when(@item)
end
def edit
@item = Item.find(params[:id])
fresh_when(@item)
</code></pre>

<p>  end
  def most_recent</p>

<pre><code>@item = Item.find(params[:id])
</code></pre>

<p>￼    fresh_when(@item)  # => fresh_when([@item, current_user.id, current_user.age])
  end
end
```</p>

<h2>Dalli &amp; Cache-Digests</h2>

<p>Dalli is a high performance pure Ruby client for accessing memcached servers.<br/>
启用：
```ruby</p>

<h1>config/environments/production.rb</h1>

<p>config.cache_store = :mem_cache_store</p>

<h1>Gemfile</h1>

<p>gem &lsquo;dalli&rsquo;</p>

<h1>Cache Store API</h1>

<p>Rails.cache.read(&lsquo;key&rsquo;)
Rails.cache.write(&lsquo;key&rsquo;, value)
Rails.cache.fetch(&lsquo;key&rsquo;) { value }</p>

<h1>config/environments/production.rb</h1>

<p>config.action_controller.perform_caching = true
```</p>

<h3>Fragment Caching</h3>

<p>在某个 Client 第一次获取 fragments 时 Rail 4同时将其放入了 Cache中，之后有同样的 Request 时 Rails 就会直接从 Cache 中读取。<br/>
使用方式：
```ruby</p>

<ul>
 <%= render document.comments %>
</ul>


<h1>变为</h1>

<p>&lt;% cache comment do %></p>

<pre><code>&lt;li&gt;&lt;%= comment %&gt;&lt;/li&gt;
</code></pre>

<p>&lt;% end %></p>

<h1>app/models/comment.rb</h1>

<p>class Comment &lt; ActiveRecord::Base
  belongs_to :document
end
<code>
上述方法和 ETags 类似，就是通过生成，保存，读取，对比 cache_key 来判断是否从 cache 读取还是重新 render ，  
但是这样会出现一个问题：如果上面代码中的 comment 没有改变，但是网页中`&lt;% cache comment do %&gt;`中的内容进行了改变，如增加了`&lt;%= comment.author %&gt;`，就会造成之前的Client仍被缓存在之前的版本中，所以需要一个 template version :
</code>ruby
&lt;% cache [&lsquo;v1&rsquo;, comment] do %>
  <li>&lt;%= comment %></li>
&lt;% end %></p>

<h1>变为</h1>

<p>&lt;% cache [&lsquo;v2&rsquo;, comment] do %>
  <li>&lt;%= comment %> &ndash; &lt;%= comment.author %></li>
&lt;% end %>
```
但是 Rails 4 中的 cache 会自动保存和对比本文件的 MD5 Hash ，当这个改变时会同样重新缓存<br/>
<strong>所以 Rails 4 无需 version</strong></p>

<h3>Cache 嵌套出现的问题</h3>

<p>```html</p>

<h1>app/views/projects/show.html.erb</h1>

<p>&lt;%= render @project.documents %></p>

<h1>app/views/documents/_document.html.erb</h1>

<p>&lt;% cache document do %>
 <article>
   <h3>&lt;%= document.title %></h3>
   <ul></p>

<pre><code> &lt;%= render document.comments %&gt;
</code></pre>

<p>   </ul>
   &lt;%= link_to &lsquo;View details&rsquo;, document %>
 </article>
 &lt;% end %></p>

<h1>app/views/comments/_comment.html.erb</h1>

<p>&lt;% cache comment do %>
   <li>&lt;%= comment %></li>
&lt;% end %>
<code>
现在模拟下述流程：
</code>
First Request to get Document 1:</p>

<pre><code>document/1     sets cache 
  comment/1    sets cache
  comment/2    sets cache
</code></pre>

<p>Second Request to get Document 1:</p>

<pre><code>document/1     reads cache 
</code></pre>

<p>Comment 2 gets Updated in Database</p>

<p>Third Request to get Document 1:</p>

<pre><code>document/1     reads cache 
</code></pre>

<p><code>
这样会发现被修改的`Comment 2`因为在`document`之内，所以无论怎么修改都仍会显示`document`的 cache，解决方法：
</code>ruby</p>

<h1>app/models/comment.rb</h1>

<p>class Comment &lt; ActiveRecord::Base
  belongs_to :document, touch: true
  belongs_to :dacer
end
<code>``
增加了</code>touch: true<code>之后comment在更新了</code>updated_at<code>时会将所</code>belongs_to<code>的document的</code>updated_at`也一同更新了</p>

<h3>Cache Digests</h3>

<p>当使用<code>helper methods</code>时必须要用<code>partial</code>:
```html
&lt;% cache document do %>
 <article>
   <h3>&lt;%= document.title %></h3>
   <ul>
   &lt;%= render document.recent_comments %> #需要替换为下面这个
   &lt;%= render partial: &ldquo;comments/comment&rdquo;,</p>

<pre><code>   collection: document.recent_comments %&gt;
</code></pre>

<p>   </ul>
   &lt;%= link_to &lsquo;More details&rsquo;, document %>
 </article>
 &lt;% end %></p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
