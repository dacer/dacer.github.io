<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code School | Dacer Blog]]></title>
  <link href="http://dacer.github.io/blog/categories/code-school/atom.xml" rel="self"/>
  <link href="http://dacer.github.io/"/>
  <updated>2014-02-16T17:56:41+08:00</updated>
  <id>http://dacer.github.io/</id>
  <author>
    <name><![CDATA[Dacer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - jQuery Part2 level 1]]></title>
    <link href="http://dacer.github.io/blog/2014/02/16/code-school-bi-ji-jquery-part2-level-1/"/>
    <updated>2014-02-16T19:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/16/code-school-bi-ji-jquery-part2-level-1</id>
    <content type="html"><![CDATA[<h3>Ajax Basics</h3>

<p>使用Ajax时需要在网站后加上<code>?dc=123</code>之类的参数时可以用<code>data</code>
```javascript
$.ajax(&lsquo;confirmation.html&rsquo;, {
   success: function(response) {</p>

<pre><code> $('.ticket').html(response).slideDown();
</code></pre>

<p>   },
   data: { &ldquo;confNum&rdquo;: 1234 }
   }
});
//confirmation.html?confNum=1234
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 5]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-5/"/>
    <updated>2014-02-15T19:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-5</id>
    <content type="html"><![CDATA[<h2>Test Your Mettle</h2>

<h3>Rake Tasks</h3>

<p><code>
rake test:models
rake test:controllers
rake test:helpers
rake test:mailers
</code></p>

<h1>需回顾：</h1>

<p><code>
ruby -Itest test/models/location_test.rb  #raises pending migration error
</code></p>

<h3>Re-Adding Performance Testing</h3>

<p>在 Rails 4 中需要添加 gem 实现
<code>
gem 'rails-perftest'
gem 'ruby-prof'
</code></p>

<h3>Skip</h3>

<p>```ruby
class ItemTest &lt; ActiveSupport::TestCase
  test &ldquo;can shorten its name&rdquo; do</p>

<pre><code>item = Item.new
item.name = "Super-duper long name"
assert_equal "Super-duper", item.short_name
</code></pre>

<p>  end
  test &ldquo;doesn&rsquo;t shorten short names&rdquo; do</p>

<pre><code>    skip #Use "skip" method if you don't want to run a test right now
item = Item.new
item.name = "Name"
assert_equal "Name", item.short_name
end 
</code></pre>

<p>end
```</p>

<h3>Minitest Test_Opts</h3>

<p>get passed as test parameters
Verbose mode shows run time and skip status for each test
```
rake test:models TEST_OPTS=&ldquo;&mdash;verbose&rdquo;
Run options: &mdash;verbose &mdash;seed 57945</p>

<h1>Running tests:</h1>

<p>ItemTest#test_can_shorten_its_name = 0.07 s = .
ItemTest#test_doesn&rsquo;t_shorten_short_names = 0.00 s = S
Finished tests in 0.076938s, 25.9950 tests/s, 12.9975
assertions/s.
2 tests, 1 assertions, 0 failures, 0 errors, 1 skips
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 4]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-4/"/>
    <updated>2014-02-15T19:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-4</id>
    <content type="html"><![CDATA[<h2>Views &amp; Vistas</h2>

<h3>Collection Form Helpers</h3>

<p>Rail 4 提供了更多的helpers
```ruby
class Owner &lt; ActiveRecord::Base
   has_many :items
end
 class Item &lt; ActiveRecord::Base
   belongs_to :owner
end</p>

<p>collection_select(:item, :owner_id, Owner.all, :id, :name)
collection_radio_buttons(:item, :owner_id, Owner.all, :id, :name)
collection_check_boxes(:item, :owner_id, Owner.all, :id, :name)
```</p>

<h3>Date Field</h3>

<p>Rails 4 提供了新的 <code>date_field</code>
<code>ruby
&lt;%= f.date_field :return_date %&gt;
</code></p>

<h3>Response Type From Controller</h3>

<p>默认返回json的格式
```ruby
def index
   @owners = Owner.all
   respond_to do |format|</p>

<pre><code> format.html
 format.json { render json: @owners }
</code></pre>

<p>   end
end
<code>
自定义json返回的格式可以用`jbuilder`或者Rails 4 中新的：
</code>ruby</p>

<h1>views/owners/index.json.ruby</h1>

<p>owners_hashes = @owners.map do |owner|
   { name: owner.name, url: owner_url(owner) }
end
owners_hashes.to_json</p>

<h1>Output</h1>

<p>[
  {&ldquo;name&rdquo;:&ldquo;Slow-draw&rdquo;,  &ldquo;url&rdquo;:&ldquo;<a href="http://localhost:3000/owners/1">http://localhost:3000/owners/1</a>&rdquo;},
  {&ldquo;name&rdquo;:&ldquo;Sheriff&rdquo;,    &ldquo;url&rdquo;:&ldquo;<a href="http://localhost:3000/owners/2">http://localhost:3000/owners/2</a>&rdquo;},
  {&ldquo;name&rdquo;:&ldquo;Walking Ned&rdquo;,&ldquo;url&rdquo;:&ldquo;<a href="http://localhost:3000/owners/3">http://localhost:3000/owners/3</a>&rdquo;}
]
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 3]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-3/"/>
    <updated>2014-02-15T19:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-3</id>
    <content type="html"><![CDATA[<h2>Strong Parameters and Remote Forms &amp; Filters, Session, Custom Flash Types</h2>

<h3>Strong Parameters</h3>

<p>在rails 4的controller中必须指定可接受的params
```ruby</p>

<pre><code>def user_params
  params.require(:user).permit(:name)
end
</code></pre>

<p><code>
其中`rquire`会检查是否有参数中的key，没有则返回400错误，但并不会将这个key的值返回到`user_params`中，`permit`则会将参数中key对应的值返回  
add this line if you want to raise errors for unpermitted params:
</code>ruby</p>

<h1>config/application.rb</h1>

<p>config.action_controller.action_on_unpermitted_parameters = :raise
```</p>

<h3>Authenticity Token</h3>

<p>Rails 会自动在form中的value加入token来防止机器人的spam</p>

<h3>Action Controller Filters/Actions</h3>

<p>3中的<code>before_filter</code>变为了<code>before_action</code>,可以让Controller在部分方法call之前做出一些动作：
```ruby
class PeopleController &lt; ActionController::Base</p>

<pre><code>before_action :set_person,      except: [ :index, :new, :create ]
before_action :ensure_permission, only: [ :edit, :update ]
</code></pre>

<p>end
```</p>

<h3>Flash Types</h3>

<p>以下方法可以生成flash信息：
<code>ruby
if @item.save
  flash[:notice] = 'Item created.'
  redirect_to @item
else
  render action: 'new'
end
</code>
```html</p>

<p><p id="notice">&lt;%= flash[:notice] %></p>
<p> <strong>Name:</strong> &lt;%= @item.name %>
</p>
<code>
其中erb部分可以简写为
</code>html
<p id="notice">&lt;%= notice %></p>
<p id="alert">&lt;%= alert %></p>
<code>
你也可以自定义flash类型
</code>ruby
class ApplicationController &lt; ActionController::Base
  add_flash_types :grunt, :snarl
end</p>

<h1>&hellip;</h1>

<p>flash[:grunt] = &lsquo;braaains&hellip;&rsquo;</p>

<h1>或者简写为</h1>

<p>redirect_to @user, grunt: &lsquo;braaains&hellip;&rsquo;
<code>
</code>html
<div id="grunt">&lt;%= grunt %></div>
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 2]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-2/"/>
    <updated>2014-02-15T15:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-2</id>
    <content type="html"><![CDATA[<h2>ActiveRecord &amp; ActiveModel</h2>

<h3>Finders</h3>

<p>米什么好说的
<code>ruby
Post.where(author: 'admin') # returns an ActiveRecord::Relation
</code></p>

<h3>Find_By</h3>

<p><code>ruby
Post.find_by(title: 'Rails 4') #returns a single model object, or possibly a collection of model objects in an Array (not a Relation). If nothing is found, an ActiveRecord::RecordNotFound exception is raised.
</code></p>

<h4>Find_by 与 where</h4>

<p>用源码解释：
```ruby
def find_by(*args)</p>

<pre><code>where(*args).take
</code></pre>

<p>end
<code>
所以可以接受和 where 一样的 arguments
</code>ruby
Post.find_by(&ldquo;published_on &lt; ?&rdquo;, 2.weeks.ago)
```</p>

<h3>Find_or_*</h3>

<p>Rail 4 简化了 3 的<code>Find_or_*</code>方法
<code>ruby
Post.find_or_initialize_by(title: "rails 4")
Post.find_or_create_by(title: "rails 4")
</code>
其中<code>find_or_create_by</code>可以和<code>after_create</code>相结合使用：
```ruby
Post.find_or_create_by(title: &lsquo;Rails 4&rsquo;)</p>

<h1>if Post not found ↓</h1>

<p>Post.create(title: &lsquo;Rails 4&rsquo;)</p>

<p>class Post &lt; ActiveRecord::Base</p>

<pre><code>after_create :foo
def foo
  posts = Post.where(author: 'admin')
  ...
    end
</code></pre>

<p>end
```</p>

<h3>Update &amp; Update_column</h3>

<p><code>ruby
@post.update(post_params) #update attribute
@post.update_columns(post_params)
</code></p>

<h3>Model.all</h3>

<p><code>ruby
@tweets = Tweet.all # returns an ActiveRecord::Relation
</code></p>

<h2>第二部分</h2>

<h3>Scopes</h3>

<p>```ruby
scope :sold, &ndash;>{ where(state: &lsquo;sold&rsquo;) } #scopes should take a proc object</p>

<p>default_scope { where(state: &lsquo;available&rsquo;) }
default_scope &ndash;>{ where(state: &lsquo;available&rsquo;) } #defaults scopes should take proc object or a block￼￼
```</p>

<h3>Eager-Loaded Scopes</h3>

<p><code>ruby
scope :recent, -&gt;{ where(published_at: 2.weeks.ago) }
scope :recent_red, -&gt;{ recent.where(color: 'red') }
</code></p>

<h3>Relation#None</h3>

<p><code>.none</code>可以返回一个空的 ActiveRecord::Relation，避免在使用空的<code>array</code>时出现错误
<code>ruby
case role
when "Reviewer"
  Post.published
when "Bad User"
  Post.none
end
</code></p>

<h3>Relation#Not</h3>

<p>在使用<code>where</code>寻找类似<code>user != ?</code>的不等于时如果参数是<code>nil</code>的话会报 SQL 错误，使用<code>.where.not</code>则会自动判别参数是否为空，且在非空时才执行SQL语句
<code>ruby
Post.where.not(author: author)
</code></p>

<h3>Relation#Order</h3>

<p>在 Rails 4 中如果<code>default_scope</code>已经有了<code>order()</code>后，再执行<code>.order</code>时这两者的先后顺序与 3 相反， Rails 4 会将<code>default_scope</code>中的放在后面：
```ruby
class User &lt; ActiveRecord::Base</p>

<pre><code>default_scope { order(:name) }
</code></pre>

<p>end</p>

<p>User.order(&ldquo;created_at DESC&rdquo;)</p>

<p>SELECT * FROM users ORDER BY name asc, created_at desc # Rails 3
SELECT * FROM users ORDER BY created_at desc, name asc # Rails 4
```</p>

<h4>手动排序</h4>

<p>Rails 4 可以使用 Hash 来排序
<code>ruby
User.order(:name, created_at: :desc)
User.order(created_at: :desc)
</code></p>

<h4>后面缩写的意思</h4>

<p>Asc : ascending order 递增<br/>
Desc : descending order 递减</p>

<h3>Relation#References</h3>

<p><code>ruby
Post.includes(:comments).
  where("comments.name = 'foo'").references(:comments)
</code>
上例中，<code>.include</code>使返回值包含了与 Post 相关联的 comments，
在一下情况则无需使用<code>references</code>
```ruby
Post.includes(:comments).where(comments: { name: &lsquo;foo&rsquo; })
Post.includes(:comments).where(&lsquo;comments.name&rsquo; => &lsquo;foo&rsquo;) #hash-based conditions</p>

<p>Post.includes(:comments).order(&lsquo;comments.name&rsquo;) #no conditions
```</p>

<h3>ActiveModel::Model</h3>

<p><code>ruby
class SupportTicket
  include ActiveModel::Conversion
  include ActiveModel::Validations
  extend ActiveModel::Naming
  attr_accessor :title, :description
  validates_presence_of :title
  validates_presence_of :description
end
</code>
可以简化为：
<code>ruby
class SupportTicket
  include ActiveModel::Model
  attr_accessor :title, :description
  validates_presence_of :title
  validates_presence_of :description
end
</code></p>
]]></content>
  </entry>
  
</feed>
