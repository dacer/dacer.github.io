<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code School | Dacer Blog]]></title>
  <link href="http://blog.dacer.im/blog/categories/code-school/atom.xml" rel="self"/>
  <link href="http://blog.dacer.im/"/>
  <updated>2014-02-17T15:30:22+08:00</updated>
  <id>http://blog.dacer.im/</id>
  <author>
    <name><![CDATA[Dacer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - jQuery Part2 level 1 & 2]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-jquery-part2-level-1-and-2/"/>
    <updated>2014-02-17T20:10:57+08:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-jquery-part2-level-1-and-2</id>
    <content type="html"><![CDATA[<h3>Ajax Basics</h3>

<p>使用Ajax时需要在网站后加上<code>?dc=123</code>之类的参数时可以用<code>data</code>
```javascript
$.ajax(&lsquo;confirmation.html&rsquo;, {
   success: function(response) {</p>

<pre><code> $('.ticket').html(response).slideDown();
</code></pre>

<p>   },
   data: { &ldquo;author&rdquo;: dacer }
   }
});
//confirmation.html?author=dacer
<code>
timeout
</code>javascript
$.ajax(&lsquo;confirmation.html&rsquo;, {
   &hellip;,
   timeout: 3000 //3000ms = 3 seconds
});
<code>`
还有`beforeSend</code>complete`等</p>

<h3>Event Delegation</h3>

<p>当你用jquery监听点击事件时只会在网页加载完毕后执行监听，如果是用ajax创造出来的是无法监听到的，所以要用到<code>Event Delegation</code>
<code>javascript
$('.confirmation .view-boarding-pass').on('click', function(){ ... }); //无法监听到
$('.confirmation').on('click', '.view-boarding-pass', function(){ ... });
</code>
以上代码是监听<code>.confirmation</code>中的点击事件，每次<code>.confirmation</code>中有元素被点击了之后都会检查是否是<code>.view-boarding-pass</code></p>

<h3>Javascript Object</h3>

<p>用<code>var</code>可以声明一个 Object ，然后将其中的function提取出来使代码更整洁
```javascript
var confirmation = {
  init: function() {</p>

<pre><code>$('.confirmation').on('click', 'button', this.loadConfirmation);
$('.confirmation').on('click', '.view-boarding-pass', this.showBoardingPass); 
</code></pre>

<p>  },
  loadConfirmation: function() {</p>

<pre><code>$.ajax('confirmation.html', { ... });
</code></pre>

<p>  },
  showBoardingPass: function(event) { &hellip; }
};</p>

<p>$(document).ready(function() {
  confirmation.init();
});
```</p>

<h3>Javascript Function</h3>

<p>用驼峰法命名一个js的function
<code>javascript
function Blog(author) {
  // init
}
var blog = new Blog('Dacer');
</code></p>

<p>function中可以嵌套function
```javascript
function Blog(author) {
  this.print = function(){</p>

<pre><code>console.log(author)
</code></pre>

<p>  }
}
var blog = new Blog(&lsquo;Dacer&rsquo;);
blog.print(); //&ldquo;Dacer&rdquo;
```</p>

<h3>用 Function 重构之前的代码</h3>

<p>```javascript
function Confirmation(el) {
  this.el = el;
  this.ticket = this.el.find(&lsquo;.ticket&rsquo;);
  var confirmation = this;
  this.loadConfirmation = function() {</p>

<pre><code>$.ajax('confirmation.html', {
  timeout: 3000,
  context: confirmation, //因为ajax内部的this和外部的不同，所以用context把内部的this替换成外部的
  success: function(response) {
    this.ticket .html(response).slideDown(); 
  }
}); 
</code></pre>

<p>  }
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 6]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-zombie-outlaws-level-6/"/>
    <updated>2014-02-17T11:10:57+08:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/17/code-school-bi-ji-zombie-outlaws-level-6</id>
    <content type="html"><![CDATA[<h2>ETags,Dalli, &amp; Cache-Digests</h2>

<h3>ETags</h3>

<p>在client请求网页时Rail 4会生成ETags一并发送回去，且client在第二次请求时会将ETags返回回来，此时Rails会再次生成ETags并与之比对，如果相同则返回304让client直接读取缓存的内容。<br/>
换句话说就是ETags是用来判断一个page是否有改变。</p>

<h3>Setting Custom ETags</h3>

<p>可以自定义ETags，<code>fresh_when</code>就是将Etags与<code>@item</code>相关联，在<code>@item.cache_key</code>不变时返回的Etags也相同，和上一节一样返回304
```ruby
class ItemsController &lt; ApplicationController
  def show</p>

<pre><code>@item = Item.find(params[:id])
</code></pre>

<p>￼    fresh_when(@item) # => headers[&lsquo;ETag&rsquo;] = Digest::MD5.hexdigest(@item.cache_key)
  end
end</p>

<h1>@item.cache_key</h1>

<h1>= &lsquo;item/2-2011224150000&rsquo;</h1>

<h1>= <model name>/ <id>&ndash;&lt;updated_at></h1>

<p>```</p>

<h3>Declarative Etags</h3>

<p>可以简化Etags的代码：
```ruby
class ItemsController &lt; ApplicationController
  etag { current_user.id }
  etag { current_user.age }
  def show</p>

<pre><code>@item = Item.find(params[:id])
fresh_when(@item)
end
def edit
@item = Item.find(params[:id])
fresh_when(@item)
</code></pre>

<p>  end
  def most_recent</p>

<pre><code>@item = Item.find(params[:id])
</code></pre>

<p>￼    fresh_when(@item)  # => fresh_when([@item, current_user.id, current_user.age])
  end
end
```</p>

<h2>Dalli &amp; Cache-Digests</h2>

<p>Dalli is a high performance pure Ruby client for accessing memcached servers.<br/>
启用：
```ruby</p>

<h1>config/environments/production.rb</h1>

<p>config.cache_store = :mem_cache_store</p>

<h1>Gemfile</h1>

<p>gem &lsquo;dalli&rsquo;</p>

<h1>Cache Store API</h1>

<p>Rails.cache.read(&lsquo;key&rsquo;)
Rails.cache.write(&lsquo;key&rsquo;, value)
Rails.cache.fetch(&lsquo;key&rsquo;) { value }</p>

<h1>config/environments/production.rb</h1>

<p>config.action_controller.perform_caching = true
```</p>

<h3>Fragment Caching</h3>

<p>在某个 Client 第一次获取 fragments 时 Rail 4同时将其放入了 Cache中，之后有同样的 Request 时 Rails 就会直接从 Cache 中读取。<br/>
使用方式：
```ruby</p>

<ul>
 <%= render document.comments %>
</ul>


<h1>变为</h1>

<p>&lt;% cache comment do %></p>

<pre><code>&lt;li&gt;&lt;%= comment %&gt;&lt;/li&gt;
</code></pre>

<p>&lt;% end %></p>

<h1>app/models/comment.rb</h1>

<p>class Comment &lt; ActiveRecord::Base
  belongs_to :document
end
<code>
上述方法和 ETags 类似，就是通过生成，保存，读取，对比 cache_key 来判断是否从 cache 读取还是重新 render ，  
但是这样会出现一个问题：如果上面代码中的 comment 没有改变，但是网页中`&lt;% cache comment do %&gt;`中的内容进行了改变，如增加了`&lt;%= comment.author %&gt;`，就会造成之前的Client仍被缓存在之前的版本中，所以需要一个 template version :
</code>ruby
&lt;% cache [&lsquo;v1&rsquo;, comment] do %>
  <li>&lt;%= comment %></li>
&lt;% end %></p>

<h1>变为</h1>

<p>&lt;% cache [&lsquo;v2&rsquo;, comment] do %>
  <li>&lt;%= comment %> &ndash; &lt;%= comment.author %></li>
&lt;% end %>
```
但是 Rails 4 中的 cache 会自动保存和对比本文件的 MD5 Hash ，当这个改变时会同样重新缓存<br/>
<strong>所以 Rails 4 无需 version</strong></p>

<h3>Cache 嵌套出现的问题</h3>

<p>```html</p>

<h1>app/views/projects/show.html.erb</h1>

<p>&lt;%= render @project.documents %></p>

<h1>app/views/documents/_document.html.erb</h1>

<p>&lt;% cache document do %>
 <article>
   <h3>&lt;%= document.title %></h3>
   <ul></p>

<pre><code> &lt;%= render document.comments %&gt;
</code></pre>

<p>   </ul>
   &lt;%= link_to &lsquo;View details&rsquo;, document %>
 </article>
 &lt;% end %></p>

<h1>app/views/comments/_comment.html.erb</h1>

<p>&lt;% cache comment do %>
   <li>&lt;%= comment %></li>
&lt;% end %>
<code>
现在模拟下述流程：
</code>
First Request to get Document 1:</p>

<pre><code>document/1     sets cache 
  comment/1    sets cache
  comment/2    sets cache
</code></pre>

<p>Second Request to get Document 1:</p>

<pre><code>document/1     reads cache 
</code></pre>

<p>Comment 2 gets Updated in Database</p>

<p>Third Request to get Document 1:</p>

<pre><code>document/1     reads cache 
</code></pre>

<p><code>
这样会发现被修改的`Comment 2`因为在`document`之内，所以无论怎么修改都仍会显示`document`的 cache，解决方法：
</code>ruby</p>

<h1>app/models/comment.rb</h1>

<p>class Comment &lt; ActiveRecord::Base
  belongs_to :document, touch: true
  belongs_to :dacer
end
<code>``
增加了</code>touch: true<code>之后comment在更新了</code>updated_at<code>时会将所</code>belongs_to<code>的document的</code>updated_at`也一同更新了</p>

<h3>Cache Digests</h3>

<p>当使用<code>helper methods</code>时必须要用<code>partial</code>:
```html
&lt;% cache document do %>
 <article>
   <h3>&lt;%= document.title %></h3>
   <ul>
   &lt;%= render document.recent_comments %> #需要替换为下面这个
   &lt;%= render partial: &ldquo;comments/comment&rdquo;,</p>

<pre><code>   collection: document.recent_comments %&gt;
</code></pre>

<p>   </ul>
   &lt;%= link_to &lsquo;More details&rsquo;, document %>
 </article>
 &lt;% end %></p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 5]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-5/"/>
    <updated>2014-02-15T19:10:57+08:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-5</id>
    <content type="html"><![CDATA[<h2>Test Your Mettle</h2>

<h3>Rake Tasks</h3>

<p><code>
rake test:models
rake test:controllers
rake test:helpers
rake test:mailers
</code></p>

<h1>需回顾：</h1>

<p><code>
ruby -Itest test/models/location_test.rb  #raises pending migration error
</code></p>

<h3>Re-Adding Performance Testing</h3>

<p>在 Rails 4 中需要添加 gem 实现
<code>
gem 'rails-perftest'
gem 'ruby-prof'
</code></p>

<h3>Skip</h3>

<p>```ruby
class ItemTest &lt; ActiveSupport::TestCase
  test &ldquo;can shorten its name&rdquo; do</p>

<pre><code>item = Item.new
item.name = "Super-duper long name"
assert_equal "Super-duper", item.short_name
</code></pre>

<p>  end
  test &ldquo;Made By Dacer&rdquo; do</p>

<pre><code>    skip #Use "skip" method if you don't want to run a test right now
blog = Blog.new
blog.author = "Dacer"
blog.url = "http://blog.dacer.im"
assert_equal "dacer", blog.short_name
end 
</code></pre>

<p>end
```</p>

<h3>Minitest Test_Opts</h3>

<p>get passed as test parameters
Verbose mode shows run time and skip status for each test
```
rake test:models TEST_OPTS=&ldquo;&mdash;verbose&rdquo;
Run options: &mdash;verbose &mdash;seed 57945</p>

<h1>Running tests:</h1>

<p>ItemTest#test_can_shorten_its_name = 0.07 s = .
ItemTest#test_doesn&rsquo;t_shorten_short_names = 0.00 s = S
Finished tests in 0.076938s, 25.9950 tests/s, 12.9975
assertions/s.
2 tests, 1 assertions, 0 failures, 0 errors, 1 skips
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 4]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-4/"/>
    <updated>2014-02-15T19:10:57+08:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-4</id>
    <content type="html"><![CDATA[<h2>Views &amp; Vistas</h2>

<h3>Collection Form Helpers</h3>

<p>Rail 4 提供了更多的helpers
```ruby
class Owner &lt; ActiveRecord::Base
   has_many :items
end
 class Item &lt; ActiveRecord::Base
   belongs_to :owner
end</p>

<p>collection_select(:item, :owner_id, Owner.all, :id, :name)
collection_radio_buttons(:item, :owner_id, Owner.all, :id, :name)
collection_check_boxes(:item, :owner_id, Owner.all, :id, :name)
```</p>

<h3>Date Field</h3>

<p>Rails 4 提供了新的 <code>date_field</code>
<code>ruby
&lt;%= f.date_field :return_date %&gt;
</code></p>

<h3>Response Type From Controller</h3>

<p>默认返回json的格式
```ruby
def index
   @owners = Owner.all
   respond_to do |format|</p>

<pre><code> format.html
 format.json { render json: @owners }
</code></pre>

<p>   end
end
<code>
自定义json返回的格式可以用`jbuilder`或者Rails 4 中新的：
</code>ruby</p>

<h1>views/owners/index.json.ruby</h1>

<p>owners_hashes = @owners.map do |owner|
   { name: owner.name, url: owner_url(owner) }
end
owners_hashes.to_json</p>

<h1>Output</h1>

<p>[
  {&ldquo;name&rdquo;:&ldquo;Slow-draw&rdquo;,  &ldquo;url&rdquo;:&ldquo;<a href="http://localhost:3000/owners/1">http://localhost:3000/owners/1</a>&rdquo;},
  {&ldquo;name&rdquo;:&ldquo;Dacer&rdquo;,    &ldquo;url&rdquo;:&ldquo;<a href="http://blog.dacer.im/">http://blog.dacer.im/</a>&rdquo;},
  {&ldquo;name&rdquo;:&ldquo;Walking Ned&rdquo;,&ldquo;url&rdquo;:&ldquo;<a href="http://localhost:3000/owners/3">http://localhost:3000/owners/3</a>&rdquo;}
]
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 3]]></title>
    <link href="http://blog.dacer.im/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-3/"/>
    <updated>2014-02-15T19:10:57+08:00</updated>
    <id>http://blog.dacer.im/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-3</id>
    <content type="html"><![CDATA[<h2>Strong Parameters and Remote Forms &amp; Filters, Session, Custom Flash Types</h2>

<h3>Strong Parameters</h3>

<p>在rails 4的controller中必须指定可接受的params
```ruby</p>

<pre><code>def user_params
  params.require(:user).permit(:name)
end
</code></pre>

<p><code>
其中`rquire`会检查是否有参数中的key，没有则返回400错误，但并不会将这个key的值返回到`user_params`中，`permit`则会将参数中key对应的值返回  
add this line if you want to raise errors for unpermitted params:
</code>ruby</p>

<h1>config/application.rb</h1>

<p>config.action_controller.action_on_unpermitted_parameters = :raise
```</p>

<h3>Authenticity Token</h3>

<p>Rails 会自动在form中的value加入token来防止机器人的spam</p>

<h3>Action Controller Filters/Actions</h3>

<p>3中的<code>before_filter</code>变为了<code>before_action</code>,可以让Controller在部分方法call之前做出一些动作：
```ruby
class PeopleController &lt; ActionController::Base</p>

<pre><code>before_action :set_person,      except: [ :index, :new, :create ]
before_action :ensure_permission, only: [ :edit, :update ]
</code></pre>

<p>end
```</p>

<h3>Flash Types</h3>

<p>以下方法可以生成flash信息：
<code>ruby
if @item.save
  flash[:notice] = 'Item created.'
  redirect_to @item
else
  render action: 'new'
end
</code>
```html</p>

<p><p id="notice">&lt;%= flash[:notice] %></p>
<p> <strong>Name:</strong> &lt;%= @item.name %>
</p>
<code>
其中erb部分可以简写为
</code>html
<p id="notice">&lt;%= notice %></p>
<p id="alert">&lt;%= alert %></p>
<code>
你也可以自定义flash类型
</code>ruby
class ApplicationController &lt; ActionController::Base
  add_flash_types :grunt, :snarl
end</p>

<h1>&hellip;</h1>

<p>flash[:grunt] = &lsquo;braaains&hellip;&rsquo;</p>

<h1>或者简写为</h1>

<p>redirect_to @user, grunt: &lsquo;I&rsquo;m Dacer&hellip;&rsquo;
<code>
</code>html
<div id="grunt">&lt;%= grunt %></div>
```</p>
]]></content>
  </entry>
  
</feed>
