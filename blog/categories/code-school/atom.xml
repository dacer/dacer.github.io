<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Code School | Dacer Blog]]></title>
  <link href="http://dacer.github.io/blog/categories/code-school/atom.xml" rel="self"/>
  <link href="http://dacer.github.io/"/>
  <updated>2014-02-15T16:20:17+08:00</updated>
  <id>http://dacer.github.io/</id>
  <author>
    <name><![CDATA[Dacer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 2]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-2/"/>
    <updated>2014-02-15T15:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-2</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Zombie Outlaws level 1]]></title>
    <link href="http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-1/"/>
    <updated>2014-02-15T15:10:57+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/15/code-school-bi-ji-zombie-outlaws-level-1</id>
    <content type="html"><![CDATA[<h2>Match Routes</h2>

<p>有两种方式
<code>
post '/somewhere', to: 'controller#action'
match '/somewhere', to: 'controller#action', via: :post
match '/somewhere', to: 'controller#action', via: :all
</code></p>

<h2>Concern</h2>

<p>用来简化route
```
concern :sociable do
  resources :comments
  resources :tags
end</p>

<p>resources :posts, concerns: :sociable
resources :items, concerns: :sociable
<code>
可以加上选项
</code>
concern :sociable do |options|
  resources :comments, options
  resources :tags, options
end</p>

<p>resources :msgs, concerns: :sociable
resources :posts, concerns: :sociable
resources :items do
  concerns :sociable, only: :create
end
<code>
可以单独封装起来
</code>ruby</p>

<h1>app/concerns/sociable.rb</h1>

<p>class Sociable</p>

<pre><code>def self.call(mapper, options)
  mapper.resources :comments, options
mapper.resources :tags, options
</code></pre>

<p>  end
end</p>

<h1>routes.rb</h1>

<p>concern :sociable， Sociable</p>

<h1>&hellip;</h1>

<p>```</p>

<h3>Thread-Safety</h3>

<p>In Rails 4
<code>ruby
MyApp::Application.configure do
  config.cache_classes = true
  config.eager_load = true
end
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 5 & 6]]></title>
    <link href="http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-5/"/>
    <updated>2014-02-14T15:40:25+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-5</id>
    <content type="html"><![CDATA[<h2>DSL</h2>

<p>yield</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 4]]></title>
    <link href="http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-4/"/>
    <updated>2014-02-14T15:40:25+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/14/code-schoolbi-ji-ruby-bits-2-level-4</id>
    <content type="html"><![CDATA[<h2>Handling Missing Methods</h2>

<p>在class中可以定义一个<code>method_missing</code>方法，当调用这个class中不存在的方法时会变为调用此方法。
```ruby
class Tweet
  def method_missing(method_name, *args)</p>

<pre><code>puts "You tried to call #{method_name} with these arguments: #{args}"
#super 可以调用ruby default方法， raises a NoMehodError.
</code></pre>

<p>  end
end
Tweet.new.submit(1, &ldquo;Here&rsquo;s a tweet.&rdquo;) # You tried to call submit with arguments: [1, &ldquo;Here&rsquo;s a tweet.&rdquo;]
<code>
利用`method_missing`可以简化很多代码，下例中就是把这个方法所在的class中的方法链接到`@user`的同名方法中了
</code>ruby
def method_missing(method_name, *args)</p>

<pre><code>@user.send(method_name, *args)
</code></pre>

<p>end
<code>
把上面的代码改进一下可以限定方法名
</code>ruby
class Tweet
  DELEGATED_METHODS = [:username, :avatar]
  def initialize(user)</p>

<pre><code>@user = user
end
</code></pre>

<p>  def method_missing(method_name, *args)</p>

<pre><code>if DELEGATED_METHODS.include?(method_name)
  @user.send(method_name, *args)
else
        super 
    end
end 
</code></pre>

<p>end
<code>
Ruby也自带了一个`delegate`可以很方便的实现上述代码
</code>ruby
require &lsquo;delegate&rsquo;
class Tweet &lt; SimpleDelegator
  def initialize(user)</p>

<pre><code>super(user)
</code></pre>

<p>  end
end
```</p>

<h3>一个跟本节不相关的知识点</h3>

<p>正则表达式提取方法：
```ruby
match = name.to_s.match(/^hash_(/w+)/)
match[1] if match #返回符合的首个子字符串，如果存在的话</p>

<pre><code>              #0为返回整个
</code></pre>

<p>```</p>

<h3>Respond_to?</h3>

<p>Tells us if an object responds to a given method<br/>
似乎可以翻译成回应一个object是否有所给的方法？
<code>ruby
tweet = Tweet.new
tweet.respond_to?(:to_s) # =&gt; true
</code>
需要注意的是，用<code>method_missing</code>实现的方法在<code>respond_to?</code>下会返回false的，所以要做如下修改：
```ruby
def respond_to?(method_name)</p>

<pre><code>method_name =~ /^hash_\w+/ || super # ||的作用是在||之前不为nil的时候返回之前的，为nil的时候返回后者
#LIST.include?(method_name.to_s) || super #或者是从一个array中判断
</code></pre>

<p>end
<code>
但是这又带来了一个问题，`.method`方法仍是error
</code>ruby
tweet.method(:hash_ruby)
<code>
在1.9.3以上版本中可以这样解决：变为`respond_to_missing?`，这样`method`就能正确返回一个 method object
</code>ruby
def respond_to_missing?(method_name)</p>

<pre><code>method_name =~ /^hash_\w+/ || super
</code></pre>

<p>end
```</p>

<h3>在 call 一个未定义方法时定义它</h3>

<p>其实我还不太理解这种用法的意义在哪儿。。
```ruby
def method_missing(method_name, *args)</p>

<pre><code>match = method_name.to_s.match(/^hash_(\w+)/)
if match
    self.class.class_eval do
        define_method(method_name) do
        @text &lt;&lt; " #" + match[1]
        end
    end
    send(method_name)
else 
    super
end 
</code></pre>

<p>end
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code School笔记 - Ruby Bits 2 Level 3]]></title>
    <link href="http://dacer.github.io/blog/2014/02/13/code-schoolbi-ji-ruby-bits-2-level-3/"/>
    <updated>2014-02-13T15:40:25+08:00</updated>
    <id>http://dacer.github.io/blog/2014/02/13/code-schoolbi-ji-ruby-bits-2-level-3</id>
    <content type="html"><![CDATA[<h2>Self</h2>

<p>在class外调用self会返回<code>main</code>，在class内调用会返回class本身。<br/>
如果在定义类中的方法时，在方法名前加<code>self</code>则这个方法会变成类似于Java的静态(static)方法
```ruby
class Tweet
  def self.f(key)</p>

<pre><code>p "#{self}"
</code></pre>

<p>  end
  def Tweet.f &hellip; #与上方一致，但不常用
end
Tweet.f(&ldquo;a&rdquo;) # => Tweet
tweet = Tweet.new
tweet.f(&ldquo;a&rdquo;) # Error!
```</p>

<h3>Class_eval</h3>

<p>重新打开一个class并往里面增加一些东西
```ruby
Tweet.class_eval do</p>

<pre><code>attr_accessor :user
</code></pre>

<p>end
```</p>

<h4>用 class_eval 写一个MethodLogger</h4>

<p>就是记录方法的使用log
```ruby
class MethodLogger</p>

<pre><code>def log_method(klass, method_name) #这里用klass是因为class在ruby中是预置的词
  klass.class_eval do
    alias_method "#{method_name}_original", method_name
    define_method method_name do
      p "#{Time.now}: Called #{method_name}"
      send "#{method_name}_original"
    end
end
</code></pre>

<p>  end
end</p>

<h1>使用</h1>

<p>class Test</p>

<pre><code>def t
end
</code></pre>

<p>end</p>

<p>logger = MethodLogger.new
logger.log_method(Test, :t)
Test.new.t
```</p>

<h3>Instance_eval</h3>

<p>类似于class_eval</p>
]]></content>
  </entry>
  
</feed>
